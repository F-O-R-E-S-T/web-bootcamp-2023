> Assigment de arquitectura

# Assigments #1

## A qué no puedes hacer esto antes de la siguiente clase 👀:

- Con tu cuenta de GitHub, crea un repósitorio y genera un "merge conflict" 😭, documenta el proceso para generarlo 🗒️ y la forma en la que lo solucionaste ✔️

- Genera al menos 3 ramas y crea commits diferentes en cada una 😱 hasta que el árbol de git se vea muy adelantado (Como con la imagen de las features) 👈🏻 En una de las ramas, has un merge y muéstranos como quedó ese árbol 🌳

### Reto extra

- ¿Muy fácil? Reto extra 🌱 usa 2 repositorios diferentes para almacenar el mismo código. ¿Fuiste la primera persona? 🏆 Quien lo haga primero se gana una asesoría de carrera con nuestro instructor 🏆

# Assignment #2

Contexto 🌲: En un aplicación web 👀 se quiere agregar un componente, ese componente debe ser interactivo con el usuario y unos de datos (Ignorando específicamente que sean esos datos) 👈🏻

Objetivo 🎯: Pensar en un componente 🧠 puede ser de cualquier tipo (ML, AI, Bolitas interactivas, representante de algo, lo que se les ocurra, etcétera). Una vez tengan una anoten el contexto ✍️ con esa descripción creen:

- Un diagrama de flujo 🍃, de como consideran que irían sus datos desde una arquitectura simple de Frontend (Interfaz), Backend (Esa cosa que hace cálculos) y base de datos (La cosa que guarda la información).

- Un diagrama de paquetes 📦, en dónde muestren como dividirían su aplicación.

- Usen al menos 3 👈🏻 diagramas diferentes (Si es mucho) de la lista que hay en el recurso: https://diagramasuml.com/ para modelar su funcionalidad ✅

Reto extra ☺️

- Si hacen esto bien 👏🏻, se van a dar cuenta de que no todos los diagramas les sirven para modelar funcionalidades chiquitas 👁. La primera persona que me diga cuáles son, 🏆 obtendra un premio secreto 🏆

# Assignment #3

Contexto 🌲: Hay muchas arquitecturas de software que me sirven para llamar, invocar o usar una funcionalidad de otro lenguaje 🐜 una de esas formas la vimos en la sesión de hace unos días, por lo que hay que practicarlo 💪🏻

Objetivo 🎯: Hacer un ejemplo de implementación basándose en UML 👁️

Tener en cuenta 🚨: La idea de esta práctica es poder usar 2 archivos para lograr una funcionalidad tan grande como quieras (Puede ser solo imprimir un texto)

Nota: Hay 2 maneras de hacer esto, hacerlo bien o hacerlo mal.

- Haciéndolo mal ❌: Haces primero el código y luego haces el UML

- Haciendo bien ✔️: Haces primero el UML y luego el código

# Assignment #4

![Assignment_4](./assignment_pre_backend.png)

---

> Assigment del backend

# Assignment #5

Crear una tabla llamada "example" dentro de alguna base de datos 🌲

# Assignment #6

Esta vez no puedo saber si lo hacen o no 👁, pero la tarea de esta vez será revisar todos los ejemplos de [JS by examples](https://javascriptbyexample.com/) 🌲

# Assignment #7

Espero que hayan entendido lo que les he venido explicado 🌱, eventualmente veremos cositas más interesantes y cositas más útiles 👀

Para esta ocasión la idea será pensar un poquito en carpetas 📂 la idea será crear lo siguiente:

🌲 Crear una carpeta de rutas en donde puedas partir las rutas 🪓

🌲 Usar archivos index.js con los cuales puedes invocar solo la carpeta sin invocar el archivo especifico 🗝

🌲 Formatear todo el API para crear tantas carpetas como consideres que sean necesarios 🤔

🌲 Has que tu API funcione 🏁

Opcional:

🍃 Usar otro lenguaje en lugar de bash, para esto solo hay que reemplazar la expresión exec

Restricciones:

❌ No muevas los archivos: .env, index.js, package.json packages-lock.json

# Assignment #8

Usualmente alguien más nos entrega los tickets, pero realmente es bueno saber como se hacen, por ende la idea de este assigment es que escriban uno. Idealmente que sea sobre software (Los quiero pero no me gustaría saber la historia de sus ex)

🌲 Usando como referencia el ticket que ya les mostré 👀 cree un ticket que tenga una descripción del problema y la respectiva tablita con datos de la dificultad y demás 📊 Todo usando markdown, por supuesto 🏁

🌲 Hay que usar un método de estimación para determinar cuanto tiempo nos vamos a tardar ⏳, para eso Robert C. Martin nos recomienda el método de estimación a 3 factores. Ya que Uncle Bob es como Jesucristo, le haremos caso 🍃

Opcional:

🍃 Describir la solución a la que llegaste

# Assignment #9

Lo qué más hace la/el dev promedio es agregar codigo a un software existente, por ende aprender a agregar piezas de código o funcionalidades a un código existente es muy importante (Sobre todo si ese código es tuyo). Para este assignment debes de cumplir lo siguiente:

🌲 Agregar la funcionalidad de actualizar un archivo usando una clase genérica (FileService) y una clase específica (ExampleService) 🏁

🌲 Conecta los endpoints y los servicios (Usando ExampleService)

🌲 Conecta los servicios entre si (Usando this)

🌲 Formatea la respuesta es res para que sea de tipo JSON

Opcional:

🍃 Agregar documentación de a tus endpoints

🍃 Agregar un método patch que haga lo mismo que put, con la diferencia de que permita agregar datos, no reescribir todo el archivo 🤔

Restricciones:

❌ Usar los métodos del servicio FileService para todo esto

# Assigment #10

Vamos a retomar cositas de planificación antes de irnos de lleno a la codificación 🌲 Hay 2 formas de hacer esto, cumplir porque si o ayudarte a ti mism@ para el futuro 💫, la idea será la siguiente:

Tomando los 4 diagramas de más abajo 🗺 debes de construir un "plan" de trabajo, para eso has de escribir todos los tickets 🎟 que encuentres entre los diagramas. Ten en cuenta que yo estimo unos 15, pero puede que tú encuentres más o menos 👍 no hay lío si te salen 20 u 8, el reto de esto es identificar las tareas que se necesitan 🎯

![Diagrama de componentes](./zorro_scape/zorrospace-Components.drawio.png "Diagrama de componentes")
![Diagrama de paquetes](./zorro_scape/zorrospace-Packages.drawio.png "Diagrama de paquetes")
![Diagrama de secuencia](./zorro_scape/zorrospace-Sequence.drawio.png "Diagrama de secuencia")
![Diagrama de estados](./zorro_scape/zorrospace-States.drawio.png "Diagrama de estados")

# Backend Project: Zorro scape

Ahora que ya sabes hacer y usar un API, vamos a construir una from scracth (Desde 0), ya sabes como hacer esto.

En la carpeta [zorro_scape](./zorro_scape/) encontrarás los build que Cristhian nos ha dejado, usa esos builds para que tu API tenga una interfaz
y envia datos compliendo la arquitectura que ya vimos. Como luego he de revisar esto, debes de hacerlo todo en un repositorio de GitHub o GitLab.


## Restricciones

- Debes de leer y actualizar un archivo de tipo json como especifica el [diagrama de componentes](./zorro_scape/zorrospace-Components.drawio.png "Diagrama de componentes")

- Solo puede comunicarte con el build a traves de /idle/current

- No puedes responder directamente JSON, primero debes leer el estado del archivo

- Todos tus endpoint deben de ser funcionales y responder cuando menos un StatusCode

## Especificación de los endpoints

### Movement

Este set de endpoints respectivamente cambian los valores de X y Y pra que le jugador se puede mover hacia arriba, derecha, izquierda y abajo

PUT: Move up

```
/http://localhost:3000/api/v1/movement/up
```

PUT: Move right

```
/http://localhost:3000/api/v1/movement/right
```

PUT: Move left

```
/http://localhost:3000/api/v1/movement/left
```

PUT: Move down

```
/http://localhost:3000/api/v1/movement/down
```

### Jump

Este set de endpoints respectivamente cambian los valores de X y Y para que el jugador se puede mover a manera de parabola, es decir; a manera de parabola

PUT: Jump right

```
/http://localhost:3000/api/v1/jump/right
```

PUT: Jump left

```
/http://localhost:3000/api/v1/jump/left
```

### Attack

Este set de endpoints se refiere a los ataques hacia la derecha e izquierda

PUT: Attack right

```
/http://localhost:3000/api/v1/attack/right
```

PUT: Attack left

```
/http://localhost:3000/api/v1/attack/left
```

### Idle

Estos endpoints son para el control del personaje, deben de cumplir con los estados propuestos para el diagrama de estados del assigment #10

GET: Get current

```
/http://localhost:3000/api/v1/idle/current
```

GET: Win

```
/http://localhost:3000/api/v1/idle/win
```

DELETE: Die

```
/http://localhost:3000/api/v1/idle/die
```

POST: Start

```
/http://localhost:3000/api/v1/idle/start
```

#### Opcional

POST: Reset

```
/http://localhost:3000/api/v1/idle/reset
```

--- 

> Assigment del frontend

# Assignment #12

Mapping, maps, mapas o cartografía; tiene muchos nombres pero se refieren a lo mismo 🗺

Escoge una página, luego lleva esa página a una topografía facilita para ti, identifica que componentes se repiten y asigna colores a todo 🌈. Una vez tengas todo eso, crear el HTML que más se ajuste a esa topografía

Recomendaciones:

🌲 Volver a ver la parte 2 de la sesión anterior (Este video de la lista de reproducción https://youtu.be/OHOWMBDUUVw)

🌲 Revisar https://htmlreference.io

# Assignment #13

Para ser un/a frontend siempre hay que estar revisando el codigo que se escribe 🌲 por ende debes de saber hacer muchas cositas, unas de esas son las arquitecturas, por ello; hemos de leer un poco sobre el tema, les propongo leer las 2 arquitecturas más usadas ⛳️

🍃 B-E_M: https://en.bem.info/methodology/quick-start/

🍃 Atomic Design: https://bradfrost.com/blog/post/atomic-web-design/

# Assigment #14: Proyecto - Parte 1: The blog

Ya que hemos visto varias maneras de como se hace frontend, algo de CSS, algo de HTML y algo de JS para el frontend ¿Y si mezclamos todo? ⛳️

🌲 Maqueta como quieres que se vea tu blog (Recuerda que lo mencionamos en la última sesión); como consejo sería bueno usar un mapa de topografía 🍃 

🌲 Crear una pequeña esctructura de como harás tu layout en HTML 🍃 

🌲 Crear una pequeña esctructura de como harás tu layout en CSS 🍃 

# Assigment #14: Proyecto - Parte 2: The blog

Ahora que ya tienes una estructura, sería bueno agregar algo de estetica ¿No crees?,
CSS es tan usualmente complicado como uno mismo quiera hacerlo, pero; las paginas,
los sitios y las apps en web son visualmente atractivas.

Para practicar esto ⛳️ usaremos una serie de recursos:

🌲 [Usaremos una fuente](https://fonts.google.com/)

🌲 [Deberíamos definir una paleta de colores](https://color.adobe.com/es/create/color-wheel)

🌲 [Un estilo para la lo que hemos hecho](https://www.crehana.com/blog/estilo-vida/tendencias-ux-ui/)

🌲 [Un poco de interactividad](https://animate.style/)

🌲 [Y una arquitectura](https://en.bem.info/methodology/)

Con todo ellos, solo has de procurar que sea esteticamente atractivo lo que diseñes,
a este punto no deberías necesitar algo más que CSS, pero si deseas puedes combinar
los estilos con algo de JS para agregar más interactividad

# Assigment #14: Proyecto - Parte 3: The blog

<div align="center">
    <i>
        "La voz humana es el instrumento más bello... Pero el más dificil de tocar"
    </i>
</div>
Richard Strauss

Si, usaremos la voz, ¿Por qué no hacerlo? La usamos todos los días, solo que; como
decía Strauss eso es dificil, en frontend lo "dificil" es sinonimo de JS/TS. Así que
has de usar la Web Speech API, la cual viene por defecto en la web.

Para esta practica debes usar:

⛳️ [Web Speech API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API)

⛳️ [Browser Compatibility](https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API#browser_compatibility)

⛳️ [JS is all you need](https://github.com/F-O-R-E-S-T/web-bootcamp-2023/tree/main/bloque_4_frontend/03_JS_is_all_you_need)

Obviamos todo esto debes hacerlo con JS; una vez hayas completado estos requerimientos minimos, tendrás un proyecto funcional.

El objetivo será:

🌲 Crear un "blog" en el cual tendrás que poder agregar conteidos mediante la voz a
un pequeño input de "preview"

🌲 En ese preview debes de poder editar y corregir el texto

🌲 El texto que generes debe de poder interpretarse con comando y algunas utilidades
por el estilo

🌲 Es importante que uses un proxy para enriquecer tu manera de escribir, así agregando
algunas comandos, la manera en la que los agreges va en ti, pero debes tener minimo 5
comando diferentes por voz que modifiquen algo en los textos, blog o pagina
